<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>es6知识汇总： | 代码笔记</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/image/log.png">
    <link rel="stylesheet" href="/css/style.css">
    <meta name="description" content="Welcome to code blog">
    
    <link rel="preload" href="/assets/css/0.styles.e593a7eb.css" as="style"><link rel="preload" href="/assets/js/app.4b1b0b93.js" as="script"><link rel="preload" href="/assets/js/2.6cb3535f.js" as="script"><link rel="preload" href="/assets/js/24.90617f6c.js" as="script"><link rel="prefetch" href="/assets/js/10.06e31df2.js"><link rel="prefetch" href="/assets/js/11.e2612193.js"><link rel="prefetch" href="/assets/js/12.b0ae31f9.js"><link rel="prefetch" href="/assets/js/13.f388ffbe.js"><link rel="prefetch" href="/assets/js/14.1b0e3af0.js"><link rel="prefetch" href="/assets/js/15.c0e22df8.js"><link rel="prefetch" href="/assets/js/16.1b9a5bd0.js"><link rel="prefetch" href="/assets/js/17.f689e822.js"><link rel="prefetch" href="/assets/js/18.656e7dc8.js"><link rel="prefetch" href="/assets/js/19.892b6a3b.js"><link rel="prefetch" href="/assets/js/20.83bb8f1c.js"><link rel="prefetch" href="/assets/js/21.edd39d5f.js"><link rel="prefetch" href="/assets/js/22.29e13568.js"><link rel="prefetch" href="/assets/js/23.713054c1.js"><link rel="prefetch" href="/assets/js/25.f3b0712b.js"><link rel="prefetch" href="/assets/js/26.2cd30cba.js"><link rel="prefetch" href="/assets/js/27.3e99b2b8.js"><link rel="prefetch" href="/assets/js/28.7e17bd21.js"><link rel="prefetch" href="/assets/js/3.d5d54d20.js"><link rel="prefetch" href="/assets/js/4.afd7b38a.js"><link rel="prefetch" href="/assets/js/5.7304001f.js"><link rel="prefetch" href="/assets/js/6.5f18f479.js"><link rel="prefetch" href="/assets/js/7.f0d75de3.js"><link rel="prefetch" href="/assets/js/8.96039f66.js"><link rel="prefetch" href="/assets/js/9.3f137593.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e593a7eb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/image/log.png" alt="代码笔记" class="logo"> <span class="site-name can-hide">代码笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blogSetUp/" class="nav-link">
  博客搭建
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端笔记" class="dropdown-title"><span class="title">前端笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端笔记" class="mobile-dropdown-title"><span class="title">前端笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front-end-notes/html-css/" class="nav-link">
  html+css
</a></li><li class="dropdown-item"><!----> <a href="/front-end-notes/js/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  js
</a></li><li class="dropdown-item"><!----> <a href="/front-end-notes/vue/" class="nav-link">
  vue
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试宝典" class="dropdown-title"><span class="title">面试宝典</span> <span class="arrow down"></span></button> <button type="button" aria-label="面试宝典" class="mobile-dropdown-title"><span class="title">面试宝典</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/baodian/html-css/" class="nav-link">
  html+css
</a></li><li class="dropdown-item"><!----> <a href="/baodian/js/" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="/baodian/vue/" class="nav-link">
  vue
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="实用网站" class="dropdown-title"><span class="title">实用网站</span> <span class="arrow down"></span></button> <button type="button" aria-label="实用网站" class="mobile-dropdown-title"><span class="title">实用网站</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          在线编辑
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://tinypng.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  图片压缩
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://www.ilovepdf.com/zh-cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  在线转换pdf文件
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          实用网站
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="http://ys.rjjd6.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  在线影音
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="http://www.pc6.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  win软件破解
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="http://www.1ppt.com/moban/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  免费ppt模板
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          前端实用在线工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://www.bejson.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JSON格式化
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="http://jsrun.net/app/ascii" target="_blank" rel="noopener noreferrer" class="nav-link external">
  在线获取键盘按键值
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          博客指南
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://juejin.im/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://blog.csdn.net/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blogSetUp/" class="nav-link">
  博客搭建
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端笔记" class="dropdown-title"><span class="title">前端笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端笔记" class="mobile-dropdown-title"><span class="title">前端笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front-end-notes/html-css/" class="nav-link">
  html+css
</a></li><li class="dropdown-item"><!----> <a href="/front-end-notes/js/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  js
</a></li><li class="dropdown-item"><!----> <a href="/front-end-notes/vue/" class="nav-link">
  vue
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试宝典" class="dropdown-title"><span class="title">面试宝典</span> <span class="arrow down"></span></button> <button type="button" aria-label="面试宝典" class="mobile-dropdown-title"><span class="title">面试宝典</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/baodian/html-css/" class="nav-link">
  html+css
</a></li><li class="dropdown-item"><!----> <a href="/baodian/js/" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="/baodian/vue/" class="nav-link">
  vue
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="实用网站" class="dropdown-title"><span class="title">实用网站</span> <span class="arrow down"></span></button> <button type="button" aria-label="实用网站" class="mobile-dropdown-title"><span class="title">实用网站</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          在线编辑
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://tinypng.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  图片压缩
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://www.ilovepdf.com/zh-cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  在线转换pdf文件
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          实用网站
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="http://ys.rjjd6.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  在线影音
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="http://www.pc6.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  win软件破解
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="http://www.1ppt.com/moban/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  免费ppt模板
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          前端实用在线工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://www.bejson.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JSON格式化
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="http://jsrun.net/app/ascii" target="_blank" rel="noopener noreferrer" class="nav-link external">
  在线获取键盘按键值
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          博客指南
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://juejin.im/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://blog.csdn.net/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>js</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front-end-notes/js/notes/js.html" class="sidebar-link">暂时只有es6知识点</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>es6</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="es6知识汇总"><a href="#es6知识汇总" class="header-anchor">#</a> es6知识汇总：</h3> <p>阮一峰ES6: https://es6.ruanyifeng.com</p> <p>知识点的3w1h: what(这是啥?), where(哪里用?), why(为什么要用?), how(怎么用?)</p> <p>[TOC]</p> <h2 id="_1-let和const"><a href="#_1-let和const" class="header-anchor">#</a> 1. let和const</h2> <h3 id="_1-let"><a href="#_1-let" class="header-anchor">#</a> 1. let</h3> <p>let是es6新增的功能,用来声明变量.
var和let声明变量有什么区别?</p> <div class="language- extra-class"><pre><code>1. 作用域不同,var声明的是函数作用域,let声明的是块级作用域
2. var具有变量声明提升,let没有变量声明提升;所以对于let变量的使用原则是:先声明后使用
3. var在同一作用域可以重复声明,后面的变量会覆盖前面的变量;let不可以,会报错
4. 什么是暂时性死区?
 - 暂时性死区(TDZ),let在当前作用域声明变量后,会绑定当前作用域;不能继续重复声明变量
 - 违反先声明后使用的原则或同一作用域重复声明变量的原则就会有暂时性死区的错误出现(注意:这是针对let的,var没有暂时性死区)
</code></pre></div><p>注意:</p> <p>​		for循环的特殊之处:</p> <p>​			1.  JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算</p> <p>​			2. 设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p> <h3 id="_2-const"><a href="#_2-const" class="header-anchor">#</a> 2.const</h3> <p>const是ES6新增的用于声明常量的关键字</p> <p>const常量的特点:</p> <ol><li><p>const常量声明的时候需要赋值,否则报错</p></li> <li><p>初始化之后不允许再次赋值,否则报错</p></li> <li><p>目前在es6中使用const修饰的数组或对象,他们内部的元素可以被修改</p> <p>比如:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//3.cosnt声明数组或对象类型常量问题</span>
        <span class="token keyword">const</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'张三'</span><span class="token punctuation">,</span><span class="token string">'李四'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> student <span class="token operator">=</span> <span class="token punctuation">{</span>
            name<span class="token operator">:</span><span class="token string">&quot;张三&quot;</span><span class="token punctuation">,</span>
            age<span class="token operator">:</span><span class="token number">22</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// names = 1;//报错,常量不能再次赋值;//const修饰的是names,并不是names数组中包含的集合内容,所以数组里面的元素是可以修改的</span>
        names<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'王五'</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//['王五','李四']</span>

        student<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//{name:'张三',age:18}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ol start="4"><li>const声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用(先声明后使用)。</li></ol></li> <li><p>const也是块级作用域.</p> <ol start="6"><li>const使用场景</li></ol></li> <li><p>多人开发环境,使用const来修饰公共的模块,不希望同事修改</p></li> <li><p>数学中Math.PI(3.14圆周率),如果被修改后面使用到的PI计算出来的数字不准确了</p></li></ol> <h3 id="_3-顶层对象的绑定"><a href="#_3-顶层对象的绑定" class="header-anchor">#</a> 3.顶层对象的绑定</h3> <ul><li><p>javascript的顶层对象是window;使用var声明的变量或函数，会绑定到顶层对象window上</p></li> <li><p>ES6中的let和const声明的全局变量不再绑定window，var声明的全局变量会绑定window</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//  javascript的顶层对象是window;使用var声明的变量或函数，会绑定到顶层对象window上</span>
<span class="token keyword">var</span> apple <span class="token operator">=</span> <span class="token string">&quot;苹果&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">getApple</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;打印苹果&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//苹果,绑定到顶层对象window上了</span>
window<span class="token punctuation">.</span><span class="token function">getApple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印苹果</span>


<span class="token comment">// let声明的全局变量不会绑定到window上</span>
<span class="token comment">// let apple = &quot;苹果&quot;;</span>
<span class="token comment">// let getApple = function() {</span>
<span class="token comment">//   console.log(&quot;打印苹果&quot;);</span>
<span class="token comment">// };</span>
<span class="token comment">// console.log(window.apple);//undefined</span>
<span class="token comment">// console.log(window.getApple);//undefined</span>

<span class="token comment">// 小结：ES6中的let声明的全局变量不再绑定window，var声明的全局变量会绑定window</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div></li></ul> <p>​</p> <h2 id="_2-变量的解构赋值"><a href="#_2-变量的解构赋值" class="header-anchor">#</a> 2. 变量的解构赋值</h2> <h3 id="_0-什么是解构赋值"><a href="#_0-什么是解构赋值" class="header-anchor">#</a> 0. 什么是解构赋值?</h3> <ul><li>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</li></ul> <p>注解:    解构赋值根据 <strong>赋值运算符</strong> 左右来划分,赋值运算符<strong>左边的是模式和变量声明</strong>,赋值运算符<strong>右面的是要解构的数组和对象</strong>;所以如何识别解构赋值(不应该把解构赋值想象成数组或对象),关键在于赋值运算符.以[]或{}出现在赋值运算符左边,一定是解构赋值(模式),反之右边一定是数组或对象.</p> <h3 id="_1-数组的解构赋值"><a href="#_1-数组的解构赋值" class="header-anchor">#</a> 1.数组的解构赋值</h3> <ul><li><p>数组解构赋值是讲究次序的,比如:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'张三'</span><span class="token punctuation">,</span><span class="token string">'李四'</span><span class="token punctuation">,</span><span class="token string">'王五'</span><span class="token punctuation">,</span><span class="token string">'赵六'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// let {zhangsan}=names;//使用形式错误,模式不匹配</span>
<span class="token comment">// let {0:zhangsan}=names;//由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构匹配</span>
<span class="token comment">// console.log(zhangsan);//张三</span>

<span class="token comment">// let [zhangsan,lisi,wangwu,zhaoliu]= names;//声明了zhangsan,lisi,wangwu,zhaoliu 这四个便量</span>
<span class="token comment">// console.log(zhangsan,lisi,wangwu,zhaoliu);</span>

<span class="token comment">// //带逗号的情况,属于不完全解构</span>
<span class="token comment">// let [,,,zhaoliu]=names;</span>
<span class="token comment">// console.log(zhaoliu);//赵六</span>
<span class="token comment">// let [,lisi]=names;</span>
<span class="token comment">// console.log(lisi);</span>
<span class="token comment">// let [,lisi,,zhaoliu]=names;</span>
<span class="token comment">// console.log(lisi,zhaoliu);</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></li></ul> <h3 id="_2-对象的解构赋值"><a href="#_2-对象的解构赋值" class="header-anchor">#</a> 2.对象的解构赋值</h3> <ul><li><p>注意事项:  对象解构赋值的时候要注意key(属性名)也是作为模式存在的;</p></li> <li><p>简写形式下有俩层含义:</p> <ol><li>它是对象解构匹配模式,</li> <li>它是要声明的变量名字</li></ol></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> student <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'张三'</span><span class="token punctuation">,</span>age<span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span>address<span class="token operator">:</span><span class="token string">'北京'</span><span class="token punctuation">}</span>
<span class="token comment">// let {age:myage} = student; //age是对象匹配模式,myage是变量名</span>
<span class="token comment">// console.log(myage);</span>

<span class="token comment">// let {name:newName,address:newAddress,age:newAge}=student;//声明了三个变量,分别是newName,newAddress,newAge</span>
<span class="token comment">// console.log(newName,newAddress,newAge);</span>

<span class="token comment">// let {name:name}=student;</span>
<span class="token comment">// console.log(name);</span>

<span class="token comment">//上述形式可以简写为:(简写后的name有俩层含义: 1.它是对象解构匹配模式, 2.它是要声明的变量名字)</span>
<span class="token comment">// let{name}=student;</span>
<span class="token comment">// console.log(name);</span>

<span class="token comment">// let {name,address,age} = student;</span>
<span class="token comment">// console.log(name,address,age);</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="_3-解构赋值默认值"><a href="#_3-解构赋值默认值" class="header-anchor">#</a> 3.解构赋值默认值</h3> <p>注意:  ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">undefined</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
x <span class="token comment">// 1</span>

<span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">null</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
x <span class="token comment">// null</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_4-函数形参的解构赋值"><a href="#_4-函数形参的解构赋值" class="header-anchor">#</a> 4.函数形参的解构赋值</h3> <ul><li>什么时候用函数形参解构赋值
<ul><li>因为函数调用的时候,实参和形参要保证数量和顺序的一致性,所以当参数比较多的时候,这个顺序和数量就很麻烦;这种情况就可以使用函数形参解构赋值来解决:
1. 使用对象解构赋值可以解决参数的顺序问题
2. 使用解构默认值可以解决参数默认值问题</li></ul></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// $.ajax({</span>
<span class="token comment">//     url: '地址',</span>
<span class="token comment">//     data: {</span>
<span class="token comment">//         参数: xxx,</span>
<span class="token comment">//         参数: xxx</span>
<span class="token comment">//     },</span>
<span class="token comment">//     type: 'POST/GET',</span>
<span class="token comment">//     success: function (str) { //成功回调函数</span>
<span class="token comment">//         alert(str);</span>
<span class="token comment">//     },</span>
<span class="token comment">//     error: function (err) { //失败回调函数</span>
<span class="token comment">//         alert(err);</span>
<span class="token comment">//     }</span>
<span class="token comment">// });</span>

<span class="token comment">//当函数形参比较多的时候,我们可以使用对象充当参数</span>

<span class="token comment">// //1.此时参数众多,形参和实参的数量顺序必须一致,否则使用会出问题</span>
<span class="token comment">// function fn(name,age,num,address,sex){</span>
<span class="token comment">//     console.log('我叫'+name+','+'今年'+age+'岁'+','+'我的学号是:'+num+','+'我家在'+address+','+'我是'+sex+'生。'); </span>
<span class="token comment">// }</span>
<span class="token comment">// fn('张三',18,'001','北京','男');</span>
<span class="token comment">// fn(12,'李四','北京','男',1)//顺序不对</span>
<span class="token comment">// fn('张三',18)//数量不对</span>


<span class="token comment">// //2.错误的示范,默认值是对的,但是形参和实参的顺序和数量不对应</span>
<span class="token comment">// //sex形参有一个默认值,为'男',他的生效前提和解构赋值一样,都需要实参严格等于undefined</span>
<span class="token comment">// function fn(name,age=21,num,address,sex='男'){</span>
<span class="token comment">//     console.log('我叫'+name+','+'今年'+age+'岁'+','+'我的学号是:'+num+','+'我家在'+address+','+'我是'+sex+'生。'); </span>
<span class="token comment">// }</span>
<span class="token comment">// fn('张三','001','北京',)</span>


<span class="token comment">// //3.此时fn的形参不是对象(注意! 注意! 注意!),他是解构赋值</span>
<span class="token comment">// function fn({name,age=21,num,address,sex='男'}){</span>
<span class="token comment">//     console.log('我叫'+name+','+'今年'+age+'岁'+','+'我的学号是:'+num+','+'我家在'+address+','+'我是'+sex+'生。'); </span>
<span class="token comment">// }</span>
<span class="token comment">// fn({</span>
<span class="token comment">//     address:'北京',</span>
<span class="token comment">//     name:'张三',</span>
<span class="token comment">//     num:'001',</span>
<span class="token comment">//     sex:'女'</span>
<span class="token comment">// })</span>

<span class="token comment">// // 上面操作就相当于:</span>
<span class="token comment">// function fn({ name, age = 21, num, address, sex = '男' } = {address: '北京',name: '张三',num: '001', sex: '女'}) {</span>
<span class="token comment">//     console.log('我叫' + name + ',' + '今年' + age + '岁' + ',' + '我的学号是:' + num + ',' + '我家在' + address + ',' + '我是' + sex + '生。');</span>
<span class="token comment">// }</span>
<span class="token comment">// //其实和对象解构赋值差不多</span>
<span class="token comment">// let {name, age = 21, num, address, sex:newSex = '男'}={address: '北京',name: '张三',num: '001', sex: '女'};</span>
<span class="token comment">// console.log(name ,age,newSex);</span>

<span class="token comment">// let { name, age = 21, num, address, sex: newSex = '男' } = {};</span>
<span class="token comment">// fn({})//后面没实参,就相当于函数里面赋值的是空对象</span>

<span class="token comment">// 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</span>
<span class="token comment">// let { name, age = 21, num, address, sex: newSex = '男' } = undefined;</span>
<span class="token comment">// fn()//这次相当于函数里面什么也没传,会报错,因为无法将undefiend转化为对象//Cannot destructure property 'name' of 'undefined' as it is undefined//无法解构“未定义”的属性</span>

<span class="token comment">//最终形式:</span>
<span class="token comment">//如何避免出现undefined   //结论: 检测到函数实参是undefined什么值也没传,就走函数形参默认值{}空对象,走空对象就走到了解构赋值默认值了,这样就避免报错了,而且还有解构赋值的默认值,如果函数传了实参,那么就直接走实参了</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">,</span> num<span class="token punctuation">,</span> address<span class="token punctuation">,</span> sex <span class="token operator">=</span> <span class="token string">'男'</span> <span class="token punctuation">}</span> <span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//={}代表的就是函数形参,默认空对象,避免报错,前面的{name,age}这是解构赋值</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我叫'</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span> <span class="token string">'今年'</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token string">'岁'</span> <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span> <span class="token string">'我的学号是:'</span> <span class="token operator">+</span> num <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span> <span class="token string">'我家在'</span> <span class="token operator">+</span> address <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span> <span class="token string">'我是'</span> <span class="token operator">+</span> sex <span class="token operator">+</span> <span class="token string">'生。'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// fn({</span>
<span class="token comment">//     name: '小张',</span>
<span class="token comment">//     num: 002,</span>
<span class="token comment">//     age: 23,</span>
<span class="token comment">//     address:&quot;北京&quot;</span>
<span class="token comment">// })</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br></div></div><h3 id="_5-字符串和数字布尔值的解构赋值"><a href="#_5-字符串和数字布尔值的解构赋值" class="header-anchor">#</a> 5.字符串和数字布尔值的解构赋值</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//通过解构赋值的概念,我们知道,解构赋值是针对数组或对象的;但是我们现在要处理字符串和数值,这可以吗?</span>
<span class="token comment">//可以,为什么呢,因为js中一切皆对象</span>

<span class="token comment">// 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</span>
<span class="token comment">// let [a] = 'hello'</span>
<span class="token comment">// console.log(a);//h</span>
<span class="token comment">// // 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</span>
<span class="token comment">// let {length} ='hello world'</span>
<span class="token comment">// console.log(length);//11</span>

<span class="token comment">// 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</span>
<span class="token comment">// let {toString}=33;//把toStrign分离出来了,所以要改变this指向,指定一个调用者</span>
<span class="token comment">//33.toStrong//平常直接使用</span>
<span class="token comment">// console.log(typeof toString.call(33));//string,解构赋值分离后的</span>
<span class="token comment">// console.log(toString);//ƒ toString() { [native code] </span>

<span class="token comment">//解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</span>
<span class="token comment">// let { toString: s } = 1024;</span>
<span class="token comment">// console.log(s === Number.prototype.toString);// true</span>
<span class="token comment">// let { toString: s } = true;</span>
<span class="token comment">// console.log(s === Boolean.prototype.toString);// true</span>


<span class="token comment">// 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。//无法解构“未定义”的属性</span>
<span class="token comment">// let { prop: x } = undefined; // TypeError</span>
<span class="token comment">// let { prop: y } = null; // TypeError</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h2 id="_3-es6的各种扩展"><a href="#_3-es6的各种扩展" class="header-anchor">#</a> 3. es6的各种扩展</h2> <h3 id="_1-字符串的扩展"><a href="#_1-字符串的扩展" class="header-anchor">#</a> 1.字符串的扩展</h3> <ol><li>模板字符串(掌握)
<ul><li>优点:  可以允许回车换行, 可读性好, 可维护性好; 嵌入表达式很方便, 不容易出错</li></ul></li> <li>标签模板(了解)
<ul><li>作用:
<ol><li>标签模板”的一个重要应用，就是过滤 HTML (标签)字符串，防止用户输入恶意内容。</li> <li>国际化(i18n)</li></ol></li></ul></li></ol> <h3 id="_2-数值的扩展"><a href="#_2-数值的扩展" class="header-anchor">#</a> 2.数值的扩展</h3> <ol><li><p>Number.isFinite():  用来检测一个数值是否为有限的(finite),即不是Infinite(无穷大或无穷小-Infinite)</p> <p>注意:  如果参数类型不是数值，<code>Number.isFinite</code>一律返回<code>false</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Number<span class="token punctuation">.</span><span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite('foo'); // falseNumber.isFinite('15'); // falseNumber.isFinite(true); // false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>Num.isNaN:  判断一个数值是否为NaN, 如果参数类型不是<code>NaN</code>，<code>Number.isNaN</code>一律返回<code>false</code>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span> <span class="token comment">// trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN('true' / 0) // trueNumber.isNaN('true' / 'true') // true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <h3 id="_3-数组的扩展"><a href="#_3-数组的扩展" class="header-anchor">#</a> 3.数组的扩展</h3> <ol><li><p>includes()方法:  用来代替以前es5中indexOf()方法;</p> <ol><li><p>includes比indexOf更具语义化,</p></li> <li><p>indexOf不能对NaN具有有效的判断</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。[NaN].indexOf(NaN)// -1[NaN].includes(NaN)// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol></li> <li><p>Array.from():  用来将类数组转换为正真的数组</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//Array.from,用来将类数组转换为真正的数组,(key值必须是下标(可以不用加引号),必须有length这个属性值,length是多少,转换完就会显示多少个元素)var obj = {    'name': &quot;张三&quot;,    'age': 13,    'sex': '男',    '1': '中国',    length: 4}var arr = Array.from(obj);console.log(arr);//(4)[undefined, &quot;中国&quot;, undefined, undefined]var obj = {    '0': &quot;张三&quot;,     1: '13',    '2': '男',    '3': '中国',    length: 2}var arr2 = Array.from(obj);console.log(arr2);//(2) [&quot;张三&quot;, &quot;13&quot;]let arrayLike = {    '0': 'a',    '1': 'b',    '2': 'c',    length: 3};// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <h3 id="_4-对象的扩展"><a href="#_4-对象的扩展" class="header-anchor">#</a> 4.对象的扩展</h3> <ol><li><p>对象属性名和方法简写</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//关键字声明函数 // 语法：function 函数名(){代码块}}//字面量声明函数//语法：var fn = function(){}//函数写在对象外边,方法写在对象里面,函数不能简写,方法可以简写// let student = {//     name:'张三',//     age:25,//     address:&quot;中国&quot;// }// console.log(student);//简写后的name或age,有俩重含义:1.表示属性名,2.表示属性值let name = '张三';let age = 14;let address = '中国';let student = {    name,//简写    age,//简写    address: address,//不简写    //没有简写的方法    sayHi: function () {        console.log(this.name);//张三        return student;    },    //简写后的方法    fn() {        console.log(this.address);//中国    }}console.log(student.name);//14console.log(student.sayHi());//{name: &quot;张三&quot;, age: 14, address: &quot;中国&quot;, sayHi: ƒ, fn: ƒ}console.log(student.fn());//undefined,以为方法没有return//小结: 对象属性名可以对常规的类型数据简写,也可以对方法进行简写(不用function声明)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>对象属性名表达式</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//要求生成一个这样的数据:	{A:[],B:[],C:[]...Z[]}let obj = {}for (let i = 0; i &lt; 26; i++) {      // 65表示A,遍历26次就是A~Z    let char = String.fromCharCode(65 + i);//将十进制ascii码转换为相应的字符    //console.log(char);//A~Z    // obj.char=[]//{char: []}  //常规对象的属性名都是字符串,现在是字符串,表达式和字符串俩回事,就相当于var obj={'char':[]}    obj[char] = [];//对象属性名表达式 ,//这种的就是表达式了,这个char就是变量了,obj={A:[],B:[],C:[]....Z:[]}}console.log(obj);//{A: Array(0), B: Array(0), C: Array(0), D: Array(0), E: Array(0), …}//对象的属性名默认为字符串,形式如下:let student = {};student.name = '张三';//字符串形式student['age'] = 18;//字符串形式console.log(student);//{name: &quot;张三&quot;, age: 18}//对象属性名表达式写法://student[表达式]student[1 &gt; 1] = '2';console.log(student);// // 关于中括号的操作:// var obj1 = {//     xingming: '李四',// }// // 中括号操作属性:// // 当你的属性赋值给一个变量的时候，这个时候，就需要选择使用中括号// var name = 'xingming';//把姓名这个属性赋值给name这个变量,// console.log(obj1[name]);//对象中括号,中括号里写变量,这样也能到用到obj1里面的xingming属性// obj1['age'] = 13;//对象属性名默认为字符串,所以age加引号,上面的name是属性名赋值的变量,所以不加引号// console.log(obj1);//{xingming: &quot;李四&quot;, age: 13}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <h3 id="_5-函数的扩展"><a href="#_5-函数的扩展" class="header-anchor">#</a> 5.函数的扩展</h3> <ol><li><p>形参默认值</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//形参默认值,传统做法// function student(name,age) {//     //利用||或运算符的短路情况(俩个满足一个情况就为true)//     age = age || 23;//第一个age为undefined,23为ture,走23,如果实参传过来,age就有值了,有值就不往后走了,所以就走实参了//     console.log(name,age);// }// // student('张三',19);//张三 19// student();//undefined 23//思考:  想让name走默认值,然后只给age赋值,是否能做到?function fn(name='李四',age=18){    console.log(name,age);}   fn();//李四 18// function fn({name='李四',age=18}){//     console.log(name,age);// }   // fn({age:23});//李四 23</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>rest参数</p> <ol><li><p>剩余参数运算符一定要出现在形参列表最后,否则报错</p></li> <li><p>如果没有剩余参数,则他的默认值是空数组[]</p></li> <li><p>它用在函数形参列表中的表现形式为 ...</p></li></ol></li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// //es5中的做法// function fn(){//     console.log(arguments.length);//5 //arguments接收实参列表,不管形参有没有定义,arguments都能接收//     console.log(arguments[2]);//3// }// fn(1,2,3,4,5)//es6中箭头函数不再支持arguments,es6提出了rest剩余参数运算符的做法function num(...args){    console.log(args);//6) [1, 2, 3, 4, 5, 6]}num(1,2,3,4,5,6);//rest运算符的表现形式为...;剩余参数运算符只能出现在形参列表的最后面//错误范例:// function fn(...agrs,a,b){//     console.log(agrs);//报错 Rest parameter must be last formal parameter //剩余参数必须是最后一个形式参数// }// fn(1,2,3,4,5)//fn方法一共定义了三个参数:a,b,agrsfunction fn(a,b,...agrs){    console.log(a);//1 //undefined    console.log(b);//2 //undefined    console.log(agrs);//(3) [3, 4, 5] //[]}// fn(1,2,3,4,5);// fn()/*小结:       1. 剩余参数运算符一定要出现在形参列表最后,否则报错      2. 如果没有剩余参数,则他的默认值是空数组[]       3. 它用在函数形参列表中的表现形式为 ... */</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="3"><li><p>箭头函数</p> <ul><li><p>箭头函数,常常用来替代 '字面量声明函数';箭头函数的写法不影响调用</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// //三种函数形式// function fn(){}//关键字声明函数// let fn1 = function(){}//字面量声明函数// let fn2 = new Function();</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>箭头函数的基本语法()=&gt;{};</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'形参'</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token comment">//函数体    console.log('hello');}fn();</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>以箭头为分割,箭头左边为形参列表,箭头右边为函数体</p> <ol><li><p>形参列表: 如果有一个形参则可以省略形参列表的圆括号,否则没有形参或多个形参的情况都不可以省略圆括号</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token comment">//没有形参的情况// var fn = () =&gt; {//     console.log('hello');// }// fn();//有一个形参的情况,形参的括号可以省略// var fn = msg =&gt; {//     console.log(msg);//hello// };// fn('hello');//多个形参的情况// var fn = (x,y)=&gt;{//     console.log(x,y);//hello world// }// fn('hello','world')</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>函数体: 如果箭头右边不写{},默认会返回右边的语句,如下:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token keyword">var</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token parameter">msg</span> <span class="token operator">=&gt;</span> msg<span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//hello</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果要返回的数据是对象,这种情况会造成歧义:  <strong>箭头函数会把对象的{},解析为函数{}</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//对象才冒号,语句块和函数内部用的都是等于号var fn = () =&gt; { name: '张三',age: 13}//报错,意外的:号,解析为函数应该用=号</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>解决方法:  <strong>加一个()圆括号构成一个表达式,消除歧义</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'张三'</span><span class="token punctuation">,</span>age<span class="token operator">:</span> <span class="token number">13</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//{name: &quot;张三&quot;, age: 13}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>箭头函数的this指向</p> <ul><li>常规函数this指向当前调用者,箭头函数内容的this不绑定当前调用者,也就是说箭头函数内this与调用者无关; 只与箭头函数的定义环境(上下文)有关(箭头函数所处的当前作用域内的this是谁,箭头函数内的this就是谁)</li></ul></li> <li><p>箭头函数的不适用场景</p> <ol><li><p>对象里的方法不适用于箭头函数声明</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> title <span class="token operator">=</span> <span class="token string">'函数外'</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    title<span class="token operator">:</span><span class="token string">'函数内'</span><span class="token punctuation">,</span>    <span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//fn为箭头函数的使用:obj.fn();//对象不构成单独作用域(不要把对象的{},理解为块作用域),此时fn箭头函数的上下文环境为obj的环境,也就是window,obj的环境是什么fn的this就是什么,所以输出: 函数外</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>事件绑定的回调函数,不适合是用箭头函数</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'press'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">toggle</span><span class="token punctuation">(</span><span class="token string">'on'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这个this,指向了window了,而不是button});</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol></li> <li><p>箭头函数有几个使用注意点:</p> <ol><li><p>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p></li> <li><p>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p></li> <li><p>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p></li> <li><p>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p></li> <li><p>箭头函数没有原型属性</p></li> <li><p>不绑定顶层对象,不会绑定到window上</p></li></ol></li></ol></li></ul></li> <li><p>name属性</p> <ul><li>函数的<code>name</code>属性，返回该函数的函数名。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>foo<span class="token punctuation">.</span>name <span class="token comment">// &quot;foo&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <h2 id="_4-symbol-了解"><a href="#_4-symbol-了解" class="header-anchor">#</a> 4. Symbol(了解)</h2> <div class="language- extra-class"><pre><code>- symbol类型是es6提出的第七种数据类型,目前一共有:**String,Number,Boolean,Undefined,Null,Object,Symbol, BigInt (大整数,es6数值的扩展有介绍)**- symbol的作用是:  产生一个独一无二的值,也就是说symbol产生的值,是symbol类型的,不会和任何一个值相等,包括同样是symbol的另外一个值。
</code></pre></div><ul><li><p>symbol值的表现形式:  不是字符串,也不是加密数字。</p></li> <li><p>symbol的作用:</p> <ol><li>防止对象属性被覆盖</li> <li>模拟es6  class的私有</li></ol></li></ul> <h2 id="_5-set和map和扩展运算符"><a href="#_5-set和map和扩展运算符" class="header-anchor">#</a> 5. Set和Map和扩展运算符</h2> <ul><li>在es5中集合类型有数组和对象,es6又新增了Set和Map俩种集合数据类型,现在一共有四种集合类型:       Object,  Array,  Set,  Map</li></ul> <h3 id="_1-set"><a href="#_1-set" class="header-anchor">#</a> 1.Set</h3> <ul><li><p>set集合与Array数组比较相似,它的常用属性和方法如下:</p> <ul><li>size属性:  类似于数组中的length, 都是用来查看数据中的长度</li> <li>add()方法:  类似于数组中的push(), 用来给set添加元素的</li> <li>delete()方法:  类似数组中的pop(), 用来删除set中指定的元素</li> <li>has()方法:  类似数组中的includes(), 用来判断set里面是否有指定的元素,如果有返回true,没有的话就返回false</li> <li>clear()方法:  清除所有set内的元素</li> <li>forEach()方法:  用来遍历set里的元素,set不能通过下标来获取元素,只能通过遍历来获取数据,不能通过for循环来遍历,因为set集合没有下标。</li></ul></li> <li><p>作用:  用来清除数组中的重复数据。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//set去重,自己的var arr = [1,2,2,1,3,4,6,4,5,]// arr.map((item)=&gt;{//     set.add(item);// })// console.log(arr);// console.log(set);//更简单的,老师的// let set1 = new Set(arr);//通过Set去重// console.log(set1);//Set(6) {1, 2, 3, 4, 6, …}// var arr1 = [...set1]//转换为了数组// console.log(arr1);//(6) [1, 2, 3, 4, 6, 5]// 再精简var arr1 = [...new Set(arr)]//把上面的直接变成一句话console.log(arr1);//(6) [1, 2, 3, 4, 6, 5]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h3 id="_2-spread和rest运算符-位置-3-5-2"><a href="#_2-spread和rest运算符-位置-3-5-2" class="header-anchor">#</a> 2.spread和rest运算符(位置: 3&gt;5&gt;2)</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//...在es6中是一个运算符,它有俩种含义: 一是:剩余参数运算符(rest), 二是:扩展运算符(spread)//1.剩余参数运算符(rest): 出现在函数的形参列表末尾叫做剩余参数运算符// function fn(...args){//     console.log(args);// }// fn(1,2,3,4,5,6,7,8,9);//2.扩展运算符(spread): 一般用于展开对象或数组(集合)里面的内容//展开数组: 能够用来进行数组的内容复制// let arr = [1,2,3];// // console.log(arr);//(3) [1, 2, 3]// // console.log(...arr);//1 2 3,数组展开// // let arr1 = ...arr;//报错意外的...// let arr1 = [...arr];//数组复制,把1,2,3放到一个数组里,然后赋值给了arr1// console.log(arr1);// //2.展开对象: 能够复制对象里面的内容// let student = { name: '张三', age: 15, sex: '男' }// let info = { title: '标题', content: &quot;内容&quot; }// let obj = {//     ...student, //     info//{name: &quot;张三&quot;, age: 15, sex: &quot;男&quot;, info: {…}}//     // ...info//{name: &quot;张三&quot;, age: 15, sex: &quot;男&quot;, title: &quot;标题&quot;, content: &quot;内容&quot;}//     //...info和数组中的comcat()合并方法效果差不多合并成一维数组,一维对象; info和数组的push()效果差不多,是二维的对象,二维数组// };// console.log(obj);// console.log(student);//3.展开Set,用来过滤重复数组内容let arr = [1,1,2,2,3,3,4,5,4,5]let set = [...new Set(arr)];//把set展开,用数组包起来,然后赋值到set,结果就变成数组了console.log(set);//[1, 2, 3, 4, 5]//用扩展运算符做数组合并var a = [1,2,3];var b = [4,5,6];var c = [...a,...b];console.log(c);//[1, 2, 3, 4, 5, 6] //扩展运算符也可以做数组合并a.push(8)console.log(a);//[1, 2, 3, 8]console.log(c);//[1, 2, 3, 4, 5, 6]//扩展运输符是深拷贝还是浅拷贝//浅拷贝</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_3-map"><a href="#_3-map" class="header-anchor">#</a> 3.Map</h3> <ul><li><p>map集合和object对象比较相似,他的常用属性和方法如下:</p> <ul><li><p>size属性:用来检测map集合中数据的长度,类似于数组中的length  如: map.size</p></li> <li><p>set()方法: 用来添加和修改map集合里的数据; 设置key,value    如:  map.set('name','张三')</p></li> <li><p>get()方法: 用来获取map集合里的value值; 根据key,获取value         如:   map.get('name')//张三</p></li> <li><p>delete()方法: 用来删除map集合里某个数据      如: map.delete('name')</p></li> <li><p>has()方法: 用来查看map集合里是否有每个数据; 根据key,判断是否存在该value  如:map.has('name')//false</p></li> <li><p>clear()方法: 清除map里的所有数据      如:map.clear()//Map(0) {}</p></li> <li><p>forEach()方法: 用来遍历map集合里所有的vlue值</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Map(3) {Array(3) =&gt; &quot;数组&quot;, {…} =&gt; &quot;对象&quot;, Array(3) =&gt; &quot;修改后的数组&quot;}//forEach遍历,把map里的value拿出来map.forEach(item=&gt;{    console.log(item);//打印的都是vlue值    //打印:     //     数组    //     对象    //     修改后的数组})</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul></li> <li><p>map特点:</p> <ul><li>map相比对象类型,map的属性名(key)可以是对象等任意类型,object对象类型的属性目前只能是字符串或symbol</li></ul></li> <li><p>map作用:</p> <ul><li>把dom对象以key的形式存储到map中的,给该key赋值;用来在dom上存储一下自定义数据。</li></ul></li></ul> <h2 id="_6-iterator-迭代器或遍历器"><a href="#_6-iterator-迭代器或遍历器" class="header-anchor">#</a> 6.iterator(迭代器或遍历器)</h2> <h3 id="_1-iterator的概念和使用"><a href="#_1-iterator的概念和使用" class="header-anchor">#</a> 1.iterator的概念和使用:</h3> <ul><li><p>iterator的作用:</p> <ul><li>用来提供一种统一的接口机制,来遍历不同的数据结构</li></ul></li> <li><p>iterator用来遍历集合类型, 我们现在了解到的集合类型有: Array,Object,Set,Map</p> <ul><li>Array,Set和Map可以使用forEach来遍历,因为它们默认有了iterator接口</li> <li>Object可以使用for in来遍历</li></ul></li> <li><p>这四种集合类型的遍历方式不同,然后当他们相互组合的时候,会产生各种变化的数据类型: 比如数组包对象,对象又包set等操作,这种操作下的遍历就更加难以统一。</p></li> <li><p>实际使用的时候,需要在数据结构上部署默认的iterator接口;然后再通过next()的调用来使用; 如下:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//Array,Set,Map默认都具备iterator接口,默认接口叫Symbol.iterator;Oject(对象)没有这个接口//我们以对象为例,来给对象部署默认iterator接口let obj = { name: '张三', age: 19, sex: &quot;男&quot; };//部署默认接口Symbol.iterator: 用来访问不同的数据结构,真正实现iterator的功效obj[Symbol.iterator] = function () {    // console.log(this);//this就代表obj//{name: &quot;张三&quot;, age: 19, sex: &quot;男&quot;, Symbol(Symbol.iterator): ƒ}    let index = 0;//记录下标    let keys = Object.keys(this);///Object.keys()可以获取对象里的所有key值,并且获取到的key值都放到了一个数组当中    // console.log(keys);//[&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;]    return {        next: () =&gt; { //1. 因为next上的方法把tis改变了,相当于没有获取到obj,所以结果shiundefined            //2. 解决方法: 把next的函数写出箭头函数,箭头函数的this还是外面obj的this            // console.log(this);//{next: ƒ}next上的函数把tis改变了            if (index &lt; keys.length) {                return { value: this[keys[index++]], done: false };            } else {                return { value: undefined, done: true };            }        }    }}console.log(obj);//{name: &quot;张三&quot;, age: 19, sex: &quot;男&quot;, Symbol(Symbol.iterator): ƒ}console.log(obj[Symbol.iterator]());//{next: ƒ},相当于上个文件中的make()方法//访问默认接口的内容let iterator = obj[Symbol.iterator]();console.log(iterator.next());//{value: &quot;张三&quot;, done: false}console.log(iterator.next());//{value: 19, done: false}console.log(iterator.next());//{value: &quot;男&quot;, done: false}console.log(iterator.next());//{value: undefined, done: true}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h3 id="_2-for-of的使用"><a href="#_2-for-of的使用" class="header-anchor">#</a> 2.for of的使用:</h3> <ul><li><p>for of是iterator的语法糖,所以部署了iterator接口的数据集合都可以使用for of遍历</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//原生具备 Iterator 接口的数据结构如下。//Array//Map//Set//String//TypedArray//函数的 arguments 对象//NodeList 对象</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>for of相比forEach和for in的优势在哪里?</p> <ol><li><code>forEach</code>无法中途跳出<code>forEach</code>循环，<code>break</code>命令或<code>return</code>命令都不能奏效。</li> <li>数组的键名(下标)是数字，但是<code>for...in</code>循环是以字符串作为键名“0”、“1”、“2”等等。</li> <li><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。不安全</li> <li>某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</li> <li>总之，<code>for...in</code>循环主要是为遍历对象而设计的，不适用于遍历数组。</li></ol></li> <li><p>for of优势:</p> <ol><li><p>有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点。</p></li> <li><p>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用。</p></li> <li><p>提供了遍历所有数据结构的统一操作接口。</p></li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//下面是一个使用 break 语句，跳出for...of循环的例子。for (var n of fibonacci) {  if (n &gt; 1000)    break;  console.log(n);}//上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用break语句跳出for...of循环。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>总结: for of适合遍历数组,  for in适合遍历对象</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//for of 用来遍历部署了iterator接口的数据集合let arr = [1,2,3,4,5,5,5,6]let set = new Set(arr);//set()里面可以传入iterable,iterable:可枚举,可遍历的东西,部署了iterator接口的就可以遍历let str = 'hello world';let map = new Map();map.set('name','张三');map.set('age',18);map.set('sex','男');// console.log(map);//{&quot;name&quot; =&gt; &quot;张三&quot;, &quot;age&quot; =&gt; 18, &quot;sex&quot; =&gt; &quot;男&quot;}//遍历数组for of  ; 遍历对象 for in// for(let item of arr){//     console.log(item);//     // 1//     // 2//     // 3//     // 4//     // 5//     // 5//     // 5//     // 6// }// //遍历map// for(let index of map){//     console.log(index);//     //[&quot;name&quot;, &quot;张三&quot;]//     // [&quot;age&quot;, 18]//     // [&quot;age&quot;, 18]// }// console.log(map.get('age'));//18//遍历set// for(let item of set){//     console.log(item);//     //1//     //2//     //3//     //4//     //5//     //6// }//错误的范例:let obj = {name:'张三',age:19,sex:'男'}for(let value of obj){    console.log(value);//报错,obj is not iterable,//obj是不可以迭代的,因为对象内部默认没有部署iterator接口,除非向上一个文件手动给对象部署iterator接口,才可以遍历}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h2 id="_7-generator生成器"><a href="#_7-generator生成器" class="header-anchor">#</a> 7.Generator生成器</h2> <ul><li><p>generator是一个函数, 只不过这个函数的写法比较特殊,再function关键字和函数名之间有一个*号,这样就构成了一个generator生成器,他不是普通的函数,他的调用不会立即执行;调用返回一个iterator,每次调用next则执行一步直到调用结束。</p></li> <li><p>generator的意义是什么?</p> <ul><li>generator内部是一个状态机(yield和return),可以使用next()的调用返回多次结果;也可以使用next传递参数给generator函数,来改变函数内部的执行逻辑</li></ul></li> <li><p>generator内部支持yield表达式,通过调用next(),可以让generators内部的yield表达式执行; 调用一次,执行一次,需要注意的是yield表达式没有返回值(返回undefined); 所以下一步的执行需要上一步的结果的时候,可以使用next()传递参数,如下:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token keyword">yield</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// console.log(first);//4    let second = yield Math.pow(first,2);//8    // console.log(second);//16    return Math.pow(second,2)//256}// let iterator = pow(2);// let {value:first} = iterator.next();//value是4// console.log(first);//4// let {value:second} = iterator.next(first);// console.log(second);//16// let {value: third } = iterator.next(second);// console.log(third);//256// console.log(iterator.next(third));// //此时使用for of不合适,因为没法传递参数// for(let iterator of pow(2)){//     console.log(iterator);// }//这个例子好理解:function* fn(arr){    console.log(arr);//(3) [1, 2, 3]    let a = yield 111;    console.log(a);//第一个yield返回值    let b = yield 222;    console.log(b);//undefined,必须让第三个next()传参,yield自己是没有参数的    let c = yield 333;    console.log(c);//第三个yield返回值}let arr = [1,2,3];let iterator = fn(arr);console.log(iterator.next());//{value: 111, done: false}console.log(iterator.next('第一个yield返回值'));//第二个next传入的参数,是第一个yield的返回值 //{value: 222, done: false}console.log(iterator.next());//{value: 333, done: false}console.log(iterator.next('第三个yield返回值'));//{value: undefined, done: true}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h2 id="_8-promise-承诺"><a href="#_8-promise-承诺" class="header-anchor">#</a> 8. promise(承诺)</h2> <ul><li><strong>promise用来解决异步数据的传递</strong></li></ul> <h3 id="_1-promise的基础介绍"><a href="#_1-promise的基础介绍" class="header-anchor">#</a> 1.promise的基础介绍</h3> <div class="language- extra-class"><pre><code>-  promise在执行过程中有三个状态:**pending**(程序执行中,没有结果);**fulfilled**(程序执行完毕,执行成功);**rejected**(程序执行完毕,执行失败)-  需要注意的是状态从pending到fulfilled或pending到rejected;这个过程是不可逆的;也就是说成功后不可能转成为失败,失败后也不可能再转为成功。
</code></pre></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/*	//声明定义promise      	1.Promise是一个构造函数: new Promise()            - 他的内部需要一个回调函数                -回调函数里面有俩个形参:resolve(成功),和reject(失败)*/</span><span class="token operator">/</span><span class="token operator">/</span><span class="token function">调用resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法<span class="token punctuation">,</span>使promise的状态从pending转换为fulfilled<span class="token comment">//调用reject()方法,使promise的状态从pending转换为reject//这里所说的成功和失败是一种逻辑上的成功和失败,有开发者自行判断let p = new Promise((resolve,reject)=&gt;{    //不一定是ajax,只要是异步执行的代码就行    $.ajax({        url: '地址',        data: {            参数: xxx,            参数: xxx        },        type: 'POST/GET',        success: function (str) { //成功回调函数            resolve(str);//调用resolve就调用下面的then()方法了,str这个形参就会传递到then()方法里的rst形参        },        error: function (err) { //失败回调函数            reject(err);//调用reject就执行下面的catch()方法了,err这个形参就传递到catch()方法里err形参了        }    });});//使用promise,使用的是p这个对象//on是用来监听事件的//then里面的回调函数为onfulfilled,catch里面的回调函数为onrejected;这俩个回调函数分别是fulfilled和rejected的事件监听函数;也就是说promise的执行状态从pending转为fulfilled的时候,onfulfilled事件监听函数就会执行(then就会执行);执行状态从pending转换到rejected的时候,onrejected事件监听函数就会执行(catch就会执行)p.then(rst=&gt;{    console.log(rst);}).catch(err=&gt;{    console.log(err);})</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="C:%5CUsers%5CAdministrator%5CPictures%5C%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%5Ces6%5C1.promise%E4%BC%A0%E5%8F%82%E7%90%86%E8%A7%A3%E5%9B%BE.jpg" alt=""></p> <h3 id="_2-promise的链式和then成功处理"><a href="#_2-promise的链式和then成功处理" class="header-anchor">#</a> 2.promise的链式和then成功处理:</h3> <ul><li>promise对象的then()内部onfulfilled监听回调函数,可以有return返回值,该值存在俩种情况:
<ol><li>返回一个promise对象
<ul><li>如果返回一个promise对象,那么下一个then()的调用将由该promise的resolve触发</li></ul></li> <li>返回一个非promise对象的值
<ul><li>非promise对象的值会作为then内部的resolve参数传递给下一个then的事件回调函数</li></ul></li></ol></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//封装一个定时器方法:function timer(msg) {    let p = new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve(msg);        }, 1000)    });    return p;//promise对象返回给timer函数}//timer().then()的调用返回promise对象,所以才能进行链式操作/*then()内部的onfulfilled监听回调函数,可以有return返回值,该值存在俩种情况:            1.返回一个promise对象                - 如果返回一个promise对象,那么下一个then()的调用将由该promise的resolve触发            2.返回一个非promise对象的值                - 非promise对象的值会作为then内部的resolve参数传递给下一个then的事件回调函数        */// //1.then()内部回调函数返回非promise对象的情况:// timer() //timer函数因为有了promise对象了,所以可以.then//     .then((rst) =&gt; {//         console.log(rst);//成功//         return ; //函数默认没有返回值,就是undefined//     })//     .then((rst) =&gt; {//         console.log(rst);//undefined//         return '2';//     })//     .then((rst) =&gt; {//         console.log(rst);//2//         return '3';//     })//     .then((rst) =&gt; {//         console.log(rst);//3//     })//2.then()内部回调函数返回promise的情况:let msg = '1秒钟';timer(msg)    .then((rst)=&gt;{    console.log(rst);//1秒钟    return timer('2秒钟');//- 如果返回一个promise对象,那么下一个then()的调用将由该promise的resolve触发})    .then((rst)=&gt;{    console.log(rst);//2秒钟    return timer();	//使用链式解决了回调地狱问题,但是不优雅})    .then((rst)=&gt;{    console.log(rst);//undefined    return;})    .then((rst)=&gt;{    console.log(rst);//undefined    return timer();})           </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_3-promise的catch异常处理"><a href="#_3-promise的catch异常处理" class="header-anchor">#</a> 3.promise的catch异常处理</h3> <ul><li><p>promise对象的then()方法可以处理onfulfilled和onrejected俩个事件监听回调,但是我们一般采用catch()方法来处理onrejected的监听回调,因为catch可以捕获部分程序异常;有利于程序的健壮性。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//也可以这样写,err但是没有.catch强大city().then((res,err)=&gt;{    console.log(res);//(4) [{…}, {…}, {…}, {…}]    console.log(err);//undefined,因为走了成功,所以失败是undefined})</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>promise对象走的是catch()方法的话,如果return err则代码进入catch;如果return其他代码,比如:return new Error('我错了'),则进入.then()。一句话就是,如果返回err就会让下面的.catch()接收到,如果返回别的话,就会让.then()接收到</p> <ul><li>我们可以利用这一特性有效的,优雅的在async...await中处理promise的异常。相似功能的第三方处理类库可以参见await-to-js。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// //请求电影院:function cinema() {    let p = new Promise((resolve, reject) =&gt; {        $.ajax({            url: 'http://www.bestqingshan.top/movie/cinema.php',            // data: {            //     //参数: xxx,            //     //参数: xxx            // },            type: 'GET',            success: function (str) { //成功回调函数                resolve(str);            },            error: function (err) { //失败回调函数                reject(err);            }        });    })    return p;}let p = cinema().then(res =&gt; {    // console.log('123123');不走这里的123123,因为这里是失败的走的是reject    return res}).catch(err =&gt; {    // console.log('123123');//走到这个,成功打印123123    // console.log(err);    // return '哈哈'//非promise对象的值会作为then内部的resolve参数传递给下一个then的事件回调函数    return err; //1.这个catch把err(返回)抛出去了,如果返回一个err(错误),就会传到下一个err上,如果不返回错误就传到下面res了    // return new Error('我错了');//也会走成功})//上面代码是异常的,也就是说必然会进入catch环节,如果return err则下面的代码进入catch;如果return其他代码,比如:return new Error('我错了'),则进入.then()。//我们可以利用这一特性有效的,优雅的在async...await中处理promise的异常。相似功能的第三方处理类库可以参见await-to-js。p.then(res =&gt; {    console.log('成功:',res);//成功: 哈哈}).catch(err =&gt; {    console.log('失败:',err);//2.底下这个err接收到了})</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h3 id="_4-promise-all-方法"><a href="#_4-promise-all-方法" class="header-anchor">#</a> 4.Promise.all()方法</h3> <ul><li><p>Promise.all()的参数是一个Promise数组,then()的返回结果也是一个数组,数组内容打印的前后顺序与all数组参数的前后顺序有关</p> <ol><li><p>他要求里面是一个数组</p></li> <li><p>数组当中就是一个promise对象</p></li> <li><p>这个结果是一个数组返回,数组当中有俩个数据,分别是俩个promise执行结果</p></li></ol></li> <li><p>Promise.all()中的promise数组参数,但凡有一个执行失败,则所有的执行都失败;执行有一定的事物性,要么全成功,要么全失败</p></li> <li><p>Promise.all()相比上面的常规操作,有一个好处,所有数据都请求回来后才能统一做处理,而不是各自处理各自的</p></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>          $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>              url<span class="token operator">:</span> <span class="token string">'http://localhost:5000/1.json'</span><span class="token punctuation">,</span>              type<span class="token operator">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span>              <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//成功回调函数                  resolve(str);              },              error: function (err) { //失败回调函数                  reject(err);              }          });      })      return p;  }    function second() {      let p = new Promise((resolve, reject) =&gt; {          $.ajax({              url: 'http://localhost:5000/2.json',              type: 'GET',              success: function (str) { //成功回调函数                  resolve(str);              },              error: function (err) { //失败回调函数                  reject(err);              }          });      })      return p;  }    //1.如果first()和second()需要顺序执行,比如:先获取first(),然后才能获取second();我们使用then()链式操作即可解决  //2.如果我们需要同时获取,我们可以使用Promise.all()来操作  // //1.常规方案:  // first().then((res) =&gt; {  //     console.log('first:',res);  // }).catch(err =&gt; {  //     console.log('first:',err);  // })  // second().then((res) =&gt; {  //     console.log('second:',res);  // }).catch(err =&gt; {  //     console.log('second:',err);  // })    //2.Promise.all()的操作:  //Promise.all()的参数是一个Promise数组,then()的返回结果也是一个数组,数组内容打印的前后顺序与all数组参数的前后顺序有关  //1.他要求里面是一个数组  //2.数组当中就是一个promise对象  //3.这个结果是一个数组返回,数组当中有俩个数据,分别是俩个promise执行结果  //Promise.all()中的promise数组参数,但凡有一个执行失败,则所有的执行都失败;执行有一定的事物性,要么全成功,要么全失败  //Promise.all()相比上面的常规操作,有一个好处,所有数据都请求回来后才能统一做处理,而不是各自处理各自的    Promise.all([first(), second()]).then(res =&gt; {      console.log(res);//(2) [{…}, {…}]  }).catch(err =&gt; {      console.log(err);  })  </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>小结:callback和promise都是用来解决异步数据的传递问题的</p> <h2 id="_9-async-await"><a href="#_9-async-await" class="header-anchor">#</a> 9.async...await</h2> <ul><li>async...await: 它是基于promise的generator语法糖;一般使用async...await来优化promise的使用</li></ul> <h3 id="_1-async"><a href="#_1-async" class="header-anchor">#</a> 1.async</h3> <ol><li><p>async是用来修饰函数的,可以单独使用</p></li> <li><p>修饰后的函数,变成了异步函数;这个函数调用后会返回一个promise对象</p></li> <li><p>该函数内部return的结果,会作为函数调用promise对象的fulfilled(成功)结果</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'hello world'</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Promise对象fn().then(res=&gt;{    console.log(res);//hello world}).catch(err=&gt;{    console.log(err);})</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <h3 id="_2-await"><a href="#_2-await" class="header-anchor">#</a> 2.await</h3> <div class="language- extra-class"><pre><code>-  await:是等待的意思,一般是等待异步执行的结果,同步也可以但是毫无意义
</code></pre></div><ol><li><p>await必须要出现在async修饰的方法中,否则会报错;也就是说await不能单独使用</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">callFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1    let result = await first();//await is only valid in async functions and the top level bodies of modules//await只能在async方法中使用中使用    console.log(result);//Object    console.log('2');//2}callFirst();</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>await用来等待一个方法的执行;该方法可以是同步的方法也可以是promise;一般用来等待promise的执行</p></li> <li><p>通过使用async...await可以让以前的then()或者catch()回调函数形式,变为同步的做法</p></li> <li><p>await等待的是promise的resolve结果,如果promise的结果是reject;await会报错,他处理不了异常,需要借助try...catch或catch来捕获异常;</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//处理await的异常://1.给等待的promise加入catch()async function callFirst() {    let result = await first().catch(err =&gt; {        console.log(err);//hello    });//异步的等待    console.log(result);//undefined}callFirst();//2.使用try...catch(){}的方法async function callFirst() {    //在try里面写的代码是容易出现异常的,或者在某种条件下必然异常    try {//检测可能出现异常的代码,不写try就直接报错了,影响后面程序的运行        let result = await first();        console.log(result);//undefined,因为异常直接在catch里处理了,所以result是undefined    } catch (err) {//处理异常//捕获异常        console.log(err);//hello    }}callFirst();</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>不管promise是成功还是失败,await都会等待异步处理,只有当异步有成功或失败的结果,才执行后续代码</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// async function callFirst() {//     let result = await first();//报错,//Uncaught (in promise) hello,捕获不了promise里的异常,需要借助try...catch或catch来捕获异常;//     console.log(result);//undefined// }// callFirst(</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <h3 id="_3-await-to-js"><a href="#_3-await-to-js" class="header-anchor">#</a> 3.await-to-js</h3> <ul><li>更加优雅的处理await的异常</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            url<span class="token operator">:</span> <span class="token string">'http://localhost:5000/1.json'</span><span class="token punctuation">,</span>            type<span class="token operator">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span>            <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//成功回调函数                resolve(str);            },            error: function (err) { //失败回调函数                reject(err);            }        });    })    return p;}function to(promise) {    return promise        .then(res =&gt; {        return [null,res];    })        .catch(err =&gt; {        return [err];    })}//备注:上述代码的then()和catch()都有return返回;下一次链式进入then()还是catch()?//	这需要看return的内容是否有异常或是否有错误;比如:throw new Error('错误'),下一次会进入catch()async function callFirst() {    let [err,res] = await to(first());    console.log(err);    console.log(res);    if(err){        //处理异常    }else{        console.log(res);    }}callFirst();</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_10-class-类"><a href="#_10-class-类" class="header-anchor">#</a> 10. class(类)</h2> <h3 id="_1-类的介绍"><a href="#_1-类的介绍" class="header-anchor">#</a> 1.类的介绍</h3> <ul><li>什么是类?
<ul><li>类是一批具有相同属性和行为的事物的抽象。类的主要作用是描述属性和行为</li></ul></li> <li>什么是属性?
<ul><li>就是一些静态的值,比如英雄联盟或王者荣耀:里面的英雄我们可以认为是一个类,所有的英雄都有血量,攻击力,防御力,法力,这些都是英雄的属性。</li></ul></li> <li>什么是行为?
<ul><li>还拿王者荣耀来举例,比如:宫本武藏有血量,攻击力,防御力等属性,那么他使用1技能或2技能在攻击的时候,他的初始攻击力是属性值(攻击力);比如:人会说话和跑步,那么说话和跑步都是行为,说话是建立在属性嘴的基础上,跑步是建立在属性腿和脚的基础上,总体意思是,行为需要依赖属性而存在的。</li></ul></li> <li>属性在程序中的表现就是一些变量</li> <li>行为在程序中的表现就是一些函数</li> <li>所以,类当中应该有变量和函数,这样来看类是一种封装,封装是面向对象的三大特征之一,(面向对象的三大特征有:封装,继承,多态)</li> <li>类和对象的关系?
<ul><li>对象是类的实例化,对象具备类所描述的属性和行为</li></ul></li></ul> <h3 id="_2-成员变量和成员方法声明的语法问题"><a href="#_2-成员变量和成员方法声明的语法问题" class="header-anchor">#</a> 2.成员变量和成员方法声明的语法问题:</h3> <ul><li><p>最终能够工作的是对象;但是在程序中必须先声明定义一个类;</p></li> <li><p>es6声明定义类使用class,比如我们定义一个Animal类</p></li> <li><p>建议类的名字首字母大写</p></li> <li><p>对象能够使用的属性和方法,我们叫做成员属性和成员方法;由于对象可以反复实例化;所以对象具备一份独立拷贝的属性和方法,不同对象的属性修改不会影响其他对象</p></li> <li><p>成员变量的声明:</p> <ol><li>声明在类内的所有方法之外(也就是类的顶层);不要有var let const this等修饰(会报错)</li> <li>成员方法:成员方法的写法和函数在对象中的简写一模一样;不要加function关键字,不要在方法结束后加逗号或分号</li></ol></li> <li><p>注意:不要把成员变量当作全局变量来使用;成员变量使用的时候需要加this</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>    <span class="token comment">//错误写法    // age:19;    // this.age:19;    // var age = 19;    //正确的成员变量声明:    leg = '腿';    foot='脚';    walk(a){        console.log('走',a);    }    run(){              //this指当前调用的对象,比如猫调用就是猫,要是狗调用就是狗        console.log('跑',this.leg,this.foot);    }    jump(){        console.log('跳');    }}//猫对象let cat = new Animal();console.log(cat);cat.leg='断了';cat.walk('路');cat.run();console.log(cat.foot);//狗对象let dog = new Animal();dog.run();</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h3 id="_3-constructor构造方法的使用"><a href="#_3-constructor构造方法的使用" class="header-anchor">#</a> 3.constructor构造方法的使用</h3> <ul><li><p>强调:在类内部的成员方法和成员变量的使用都需要this</p></li> <li><p>constructor是构造函数,他是在new实例化的时候自动调用执行的,不用手动调用;构造函数的作用是初始化成员变量的或调用成员方法;构造方法不需要有return返回</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>    <span class="token comment">//成员变量(成员属性)    engine='发动';    wheels;    engine='火箭';//成员变量重名也是会覆盖的    constructor(newEngine,newWheels){//构造函数接收        this.engine=newEngine;//初始化成员变量        this.wheels=newWheels;        this.run();//调用成员方法	}    //成员方法    run() {        console.log('跑', this.engine);    }    //成员方法重名会覆盖    run() {        console.log('跳');    }}let car = new Car('发动机','轮胎');//构造函数传参console.log(car.engine);console.log(car.wheels);// car.engine = '发动机';// car.engine = '发动机';car.run();</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h3 id="_4-静态和成员的区别"><a href="#_4-静态和成员的区别" class="header-anchor">#</a> 4.静态和成员的区别</h3> <ul><li><p>静态的就是类的,也就是说静态变量是类能够使用的变量,静态方法就是类能够使用的方法</p></li> <li><p>成员的就是对象的;成员变量就是对象能够使用的变量;成员方法就是对象能够使用的方法</p></li> <li><p>静态和成员的区别?</p> <p>​    1. 静态属性和方法由类去调用,成员的属性和方法由对象来调用;不能交叉,否则报错</p> <p>​    2.成员属性和方法都有一份属于自己的独立拷贝,静态属性和方法全局独一份</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Car</span><span class="token punctuation">{</span>    <span class="token comment">//第一种静态写法:    static title = '汽车';    engine='发动机';    wheels='轮胎';    constructor(){}//构造函数对类来说是没用的,类都传不了值,对成员来说是有用的    run(){        console.log('跑');    }    static sayHi(){        console.log('滴滴');    }}// 第二种声明静态变量和方法的写法:Car.brand='品牌';//静态变量,因为使用类名弄的变量Car.sayHello=function(){//静态方法    console.log('你好');}// class Car{}// Identifier 'Car' has already been declared //Car已经被声明了,不能重复声明类//成员变量的方法和使用let car = new Car();// console.log(car.title); //undefined 对象调用静态属性undefined,获取不到// car.sayHi();//对象调用静态方法会报错, car.sayHi is not a function sayHi不是函数//静态属性和方法的使用:Car.title='卡车'console.log(Car.title);//头部 //类调用成员变量同样也是获取不到undefinedCar.sayHi();//滴滴 //类调用成员方法同样是报错run不是函数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h3 id="_5-class的继承"><a href="#_5-class的继承" class="header-anchor">#</a> 5.class的继承</h3> <ul><li><p>在es6中使用extends实现继承</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//在es6中使用extends实现继承class  Animal{    static title = '动物';    type='肉食者';    sayHi(){        console.log('大叫一声');    }    static sayHello(){        console.log('哈喽');    }}class Cat extends Animal{ //猫继承动物    blcak='黑夜动物';}let cat = new Cat();//cat继承过来的属性console.log(cat.type);//肉食者cat.sayHi();//大叫一声console.log(Cat.title);//动物Cat.sayHello();//哈喽//cat自己的属性:console.log(cat.blcak);//黑夜动物</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h3 id="_6-super用法"><a href="#_6-super用法" class="header-anchor">#</a> 6.super用法</h3> <ol><li><p>super()方法:只能出现在有继承的子类constructor方法第一行,否则报错;用来初始化父类的constructor</p></li> <li><p>super.对象:一般使用super对象的场景是,子类出现了覆盖父类同名方法和属性的做法;子类的对象就无法再使用父类的同名方法或属性了,但是子类可以通过super对象来调用父类被覆盖的属性和方法</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>    weight<span class="token punctuation">;</span><span class="token comment">//体重    height;//身高    //不要期待使用contructor去声明变量,这不直观    constructor(newH, newW) {        // super();//报错, super' keyword unexpected here        this.height = newH;        this.weight = newW;    }    sayHi(){        console.log('大叫一声');    }}class Cat extends Animal {    eyes;//眼睛    mouse;//嘴    color;    constructor(eyes,mouse,color,newH, newW){//super()初始化父类构造函数的        super(newH, newW);//super方法会调用父类的constructor构造方法,用来初始化父类的参数        this.eyes=eyes;        this.mouse=mouse;        this.color=color;    }    jump(){                  // super.sayHi();//super可以在子类方法中调用父类方法        console.log('跳到高');    }    //这种子类覆盖父类的写法是因为父类的方法不能满足子类的需求;覆盖后子类对象无法再调用父类的同名方法    sayHi(){        // super.sayHi();//使用super可以继续调用,和父类同名的方法        console.log('喵喵叫');    }}let cat = new Cat('蓝色眼睛','小小嘴','小花猫','30cm','10kg');console.log(cat);cat.sayHi();//大叫一声cat.jump();//跳到高</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.4b1b0b93.js" defer></script><script src="/assets/js/2.6cb3535f.js" defer></script><script src="/assets/js/24.90617f6c.js" defer></script>
  </body>
</html>
